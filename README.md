# Лабораторная работа №1: Динамическое программирование

## Теоретическая часть

### 1. Что такое динамическое программирование?

Динамическое программирование представляет собой методологию решения вычислительных задач, основанную на двух ключевых принципах:
- **Разделение задачи** на перекрывающиеся подзадачи более низкого порядка
- **Кэширование промежуточных результатов** для предотвращения избыточных вычислений

Этот подход особенно эффективен для задач, обладающих свойством оптимальной подструктуры, когда оптимальное решение всей задачи может быть составлено из оптимальных решений её подзадач. Классические примеры применения: задачи оптимизации последовательностей, вычисление расстояния Левенштейна, задача о рюкзаке.

### 2. Что такое Big O нотация?

Big O нотация формализует анализ эффективности алгоритмов через асимптотические оценки:
- **Временная сложность** – зависимость времени выполнения от размера входных данных
- **Пространственная сложность** – зависимость объёма потребляемой памяти от размера входных данных

Обозначения описывают верхнюю границу роста ресурсов в худшем случае:
- **O(1)** – константное время/память (доступ к элементу массива)
- **O(n)** – линейная зависимость (поиск минимума в неотсортированном массиве)
- **O(n²)** – квадратичная зависимость (алгоритмы с вложенными циклами)
- **O(log n)** – логарифмическая зависимость (бинарный поиск)

### 3. Что такое мемоизация в рекурсии?

Мемоизация – техника оптимизации рекурсивных алгоритмов через кэширование результатов выполнения функций для конкретных входных параметров. При повторном вызове с теми же аргументами вместо повторного вычисления результат извлекается из кэша.

Этот механизм преобразует экспоненциальную временную сложность в полиномиальную (например, для чисел Фибоначчи сложность снижается с O(2ⁿ) до O(n)). В Python мемоизацию легко реализовать через декоратор `@lru_cache` или вручную с использованием словаря для хранения результатов.

## Практическая часть

### Решение задачи Climbing stairs

Алгоритм использует математическую формулу для прямого вычисления n-го числа Фибоначчи. Хотя классическое динамическое программирование для этой задачи использует итеративное накопление значений, данное решение применяет точную аналитическую формулу (формула Бине), что обеспечивает теоретическую временную сложность O(1).

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        return int( ( ( ( 1 + (5 ** 0.5) )  / 2 ) ** ( n + 1 ) - ( ( 1 - (5 ** 0.5) )  / 2 ) ** ( n + 1 ) ) / (5 ** 0.5) )
```

### Решение задачи Jump game 2

Решение реализует жадную стратегию с линейной временной сложностью O(n). Алгоритм отслеживает три ключевые переменные:
- `farthest` – максимально достижимая позиция из текущего диапазона
- `current_end` – граница текущего прыжка
- `jumps` – счётчик выполненных прыжков

На каждом шаге обновляется максимально достижимая позиция. При достижении границы текущего прыжка увеличиваем счётчик и переносим границу к максимально достижимой позиции.

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        jumps = 0
        current_end = 0
        farthest = 0

        for i in range(n - 1):
            farthest = max(farthest, i + nums[i])
            if i == current_end:
                jumps += 1
                current_end = farthest
        
        return jumps
```

### Решение задачи Pascal's triangle 2

Алгоритм использует свойства биномиальных коэффициентов для прямого вычисления элементов требуемой строки. Вместо классического построения всего треугольника Паскаля применяется встроенная функция `math.comb`, вычисляющая комбинации C(n, k). Это обеспечивает временную сложность O(n) с минимальными затратами памяти.

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        return [math.comb(rowIndex, i) for i in range(rowIndex + 1)]
```

### Решение задачи Best time to buy and sell stock 1

Решение за один проход по массиву отслеживает минимальную цену покупки и максимальную возможную прибыль. Для каждой цены проверяем:
1. Можно ли обновить минимальную цену покупки
2. Дает ли текущая цена лучшую прибыль при продаже после минимальной покупки

Этот подход гарантирует нахождение оптимального решения с временной сложностью O(n) и пространственной O(1).

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = prices[0]
        max_profit = 0

        for price in prices[1:]:
            if price < min_price:
                min_price = price
            elif price - min_price > max_profit:
                max_profit = price - min_price

        return max_profit
```

### Решение задачи Best time to buy and sell stock 2

Для задачи с неограниченным количеством сделок алгоритм суммирует все положительные изменения цены между последовательными днями. Эта стратегия эквивалентна покупке в начале каждого восходящего тренда и продаже в его конце. Решение работает за линейное время O(n) и не требует дополнительной памяти.

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0

        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                max_profit += prices[i] - prices[i - 1]

        return max_profit
```